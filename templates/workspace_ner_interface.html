{% extends 'base.html' %}
{% load static %}

{% block title %}NER ì£¼ì„ ì‘ì—…ê³µê°„ - KDPII NER Labeler{% endblock %}

{% block extra_css %}
<style>
    .annotation-container {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }
    
    .text-display {
        padding: 30px;
        font-size: 16px;
        line-height: 1.8;
        border-bottom: 1px solid #e9ecef;
        min-height: 200px;
        background: #fafbfc;
        user-select: text;
        cursor: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
    }
    
    .text-display p {
        margin: 0;
        user-select: text;
        -webkit-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
    }
    
    .label-controls {
        padding: 20px;
        background: white;
    }
    
    .label-button {
        margin: 5px;
        padding: 8px 16px;
        border: 2px solid transparent;
        border-radius: 20px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        display: inline-block;
    }
    
    .label-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .label-button.selected {
        border-color: currentColor;
        box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
    }
    
    .annotation-stats {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 12px;
        margin-bottom: 20px;
    }
    
    .task-navigation {
        background: white;
        padding: 15px;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        text-align: center;
    }
    
    .highlight {
        padding: 2px 4px;
        margin: 0 1px;
        border-radius: 3px;
        cursor: pointer;
        position: relative;
    }
    
    .highlight:hover::after {
        content: attr(title);
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: #333;
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000;
    }
    
    .selected-text {
        background: rgba(0, 123, 255, 0.2);
        border: 2px solid rgba(0, 123, 255, 0.5);
        border-radius: 3px;
        padding: 1px 2px;
    }
    
    .upload-area:hover {
        border-color: #28a745 !important;
        background-color: rgba(40, 167, 69, 0.05) !important;
    }
    
    .upload-area.dragover {
        border-color: #28a745 !important;
        background-color: rgba(40, 167, 69, 0.1) !important;
        transform: scale(1.02);
    }
    
    .file-history-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 8px 12px;
        background: #f8f9fa;
        border: 1px solid #e8e8e8;
        border-radius: 3px;
        margin-bottom: 4px;
        font-size: 12px;
    }
    
    .file-history-item.success {
        border-left: 3px solid #28a745;
    }
    
    .file-history-item.failed {
        border-left: 3px solid #dc3545;
    }
    
    .file-history-item.processing {
        border-left: 3px solid #ffc107;
    }
    
    .export-section {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-top: 20px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid my-4">
    <!-- Header -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <h1 class="h3 mb-1">
                        <i class="fas fa-edit text-primary me-2"></i>NER ì£¼ì„ ì‘ì—…ê³µê°„
                    </h1>
                    <p class="text-muted mb-0">í˜„ì¬ ì‘ì—…: <span id="current-task-name">ë¡œë”© ì¤‘...</span></p>
                </div>
                <div class="text-end">
                    <button class="btn btn-outline-primary me-2" onclick="saveAnnotations()">
                        <i class="fas fa-save me-1"></i>ì €ì¥
                    </button>
                    <a href="{% url 'ner_labeler:dashboard' %}" class="btn btn-secondary">
                        <i class="fas fa-arrow-left me-1"></i>ëŒ€ì‹œë³´ë“œ
                    </a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Stats Row -->
    <div class="row mb-4">
        <div class="col-md-3">
            <div class="annotation-stats text-center">
                <h4 id="progress-count">0/0</h4>
                <p class="mb-0">ì™„ë£Œëœ ì‘ì—…</p>
            </div>
        </div>
        <div class="col-md-9">
            <div class="task-navigation">
                <button class="btn btn-outline-primary me-2" onclick="previousTask()" id="prev-btn">
                    <i class="fas fa-chevron-left"></i> ì´ì „
                </button>
                <span class="mx-3">
                    <strong id="task-counter">1 / 1</strong>
                </span>
                <button class="btn btn-outline-primary ms-2" onclick="nextTask()" id="next-btn">
                    ë‹¤ìŒ <i class="fas fa-chevron-right"></i>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Main Annotation Area -->
    <div class="row">
        <div class="col-lg-8">
            <div class="annotation-container">
                <div class="text-display" id="text-display">
                    <p class="text-muted text-center">ì‘ì—…ì„ ë¡œë“œí•˜ëŠ” ì¤‘ì…ë‹ˆë‹¤...</p>
                </div>
                <div class="label-controls">
                    <h6 class="mb-3">ë¼ë²¨ ì„ íƒ (ì„ íƒí•œ í…ìŠ¤íŠ¸ì— ì ìš©ë©ë‹ˆë‹¤)</h6>
                    <div id="label-buttons">
                        <!-- Label buttons will be loaded here -->
                    </div>
                    
                    <!-- Label selection status display -->
                    <div id="label-selection-status" class="mt-3">
                        <div class="alert alert-secondary py-2">
                            <i class="fas fa-info-circle me-1"></i>ë¼ë²¨ì„ ì„ íƒí•˜ì„¸ìš”
                        </div>
                    </div>
                    
                    <div class="mt-3">
                        <button class="btn btn-sm btn-warning me-2" onclick="clearSelection()">
                            <i class="fas fa-eraser me-1"></i>ì„ íƒ í•´ì œ
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="removeAnnotation()">
                            <i class="fas fa-trash me-1"></i>ì£¼ì„ ì œê±°
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-lg-4">
            <!-- Current Annotations -->
            <div class="card mb-4">
                <div class="card-header">
                    <h6 class="mb-0"><i class="fas fa-list me-2"></i>í˜„ì¬ ì£¼ì„ ëª©ë¡</h6>
                </div>
                <div class="card-body">
                    <div id="annotations-list">
                        <p class="text-muted">ì•„ì§ ì£¼ì„ì´ ì—†ìŠµë‹ˆë‹¤.</p>
                    </div>
                </div>
            </div>
            
            <!-- Instructions -->
            <div class="card">
                <div class="card-header">
                    <h6 class="mb-0"><i class="fas fa-info-circle me-2"></i>ì‚¬ìš©ë²•</h6>
                </div>
                <div class="card-body">
                    <ol class="mb-0 ps-3">
                        <li>í…ìŠ¤íŠ¸ì—ì„œ ê°œì²´ëª…ì„ ë“œë˜ê·¸í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”</li>
                        <li>ì ì ˆí•œ ë¼ë²¨ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”</li>
                        <li>ì£¼ì„ì´ ìë™ìœ¼ë¡œ ì ìš©ë©ë‹ˆë‹¤</li>
                        <li>ì €ì¥ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‘ì—…ì„ ì €ì¥í•˜ì„¸ìš”</li>
                    </ol>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Upload Section - Old UI Style -->
    <div class="row mt-4">
        <div class="col-12">
            <div class="upload-section" style="background: white; border-radius: 3px; box-shadow: 2px 2px 8px #AAA; border: 1px solid #e8e8e8;">
                <div class="upload-header" style="padding: 12px 16px; border-bottom: 1px solid #e8e8e8; background: #f8f9fa; border-radius: 3px 3px 0 0;">
                    <h6 class="mb-0" style="color: #2c3e50; font-size: 14px; font-weight: 600;">
                        <i class="fas fa-upload me-2"></i>ì‘ì—… íŒŒì¼ ì—…ë¡œë“œ
                    </h6>
                </div>
                <div class="upload-body" style="padding: 20px;">
                    <div class="upload-area" id="upload-area" 
                         style="border: 2px dashed #dee2e6; border-radius: 4px; padding: 30px; text-align: center; cursor: pointer; transition: all 0.2s ease; background: #f8f9fa;"
                         ondrop="dropHandler(event);" 
                         ondragover="dragOverHandler(event);"
                         ondragenter="dragEnterHandler(event);"
                         ondragleave="dragLeaveHandler(event);">
                        <div class="upload-icon" style="font-size: 48px; margin-bottom: 15px;">ğŸ“</div>
                        <p class="upload-title" style="font-size: 16px; font-weight: 500; color: #2c3e50; margin-bottom: 8px;">
                            íŒŒì¼ì„ ì—¬ê¸°ì— ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì„ íƒí•˜ì„¸ìš”
                        </p>
                        <p class="upload-subtitle" style="font-size: 13px; color: #6c757d; margin-bottom: 15px;">
                            ì§€ì› í˜•ì‹: TXT, CSV, TSV, JSON, JSONL
                        </p>
                        <div class="upload-details" style="font-size: 12px; color: #6c757d; margin-bottom: 20px;">
                            <small>â€¢ TXT: í•œ ì¤„ë‹¹ í•˜ë‚˜ì˜ ì‘ì—…</small><br>
                            <small>â€¢ CSV/TSV: ê° í–‰ì´ í•˜ë‚˜ì˜ ì‘ì—…</small><br>
                            <small>â€¢ JSON: ê°ì²´ ë°°ì—´ ë˜ëŠ” ë‹¨ì¼ ê°ì²´</small><br>
                            <small>â€¢ JSONL: JSON Lines (í•œ ì¤„ë‹¹ í•˜ë‚˜ì˜ JSON ê°ì²´)</small><br>
                            <small style="color: #999;">ìµœëŒ€ íŒŒì¼ í¬ê¸°: 16MB</small>
                        </div>
                        <button class="btn" style="background: #28a745; color: white; border: 1px solid #28a745; padding: 8px 16px; font-size: 12px; border-radius: 3px;" 
                                onclick="document.getElementById('file-input').click();">
                            <i class="fas fa-folder-open me-1"></i>íŒŒì¼ ì„ íƒ
                        </button>
                        <input type="file" id="file-input" accept=".txt,.csv,.tsv,.json,.jsonl" 
                               onchange="handleFileSelect(event)" style="display: none;">
                    </div>
                    
                    <div id="upload-progress" style="display: none; margin-top: 20px;">
                        <div class="progress" style="height: 20px; background-color: #e9ecef; border-radius: 3px; overflow: hidden;">
                            <div class="progress-bar" role="progressbar" style="width: 0%; background-color: #28a745; transition: width 0.3s ease;"></div>
                        </div>
                        <p class="text-center mt-2" style="margin: 0; color: #6c757d; font-size: 13px;">
                            <span id="upload-status">ì—…ë¡œë“œ ì¤‘...</span>
                        </p>
                    </div>
                    
                    <!-- File History -->
                    <div id="file-history" style="margin-top: 20px; display: none;">
                        <h6 style="color: #2c3e50; font-size: 13px; margin-bottom: 10px;">ìµœê·¼ ì—…ë¡œë“œëœ íŒŒì¼</h6>
                        <div id="file-history-list" style="max-height: 150px; overflow-y: auto;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Export Section -->
    <div class="row mt-4">
        <div class="col-12">
            <div class="export-section">
                <h6 class="mb-3"><i class="fas fa-download me-2"></i>ë‚´ë³´ë‚´ê¸°</h6>
                <div class="btn-group">
                    <button class="btn btn-outline-success" onclick="exportJSON()">
                        <i class="fas fa-file-code me-1"></i>JSON í˜•ì‹
                    </button>
                    <button class="btn btn-outline-info" onclick="exportCoNLL()">
                        <i class="fas fa-file-alt me-1"></i>CoNLL í˜•ì‹
                    </button>
                    <button class="btn btn-outline-primary" onclick="exportLabelStudio()">
                        <i class="fas fa-file-export me-1"></i>Label Studio í˜•ì‹
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Global variables
let currentTask = null;
let currentTaskIndex = 0;
let tasks = [];
let labels = [];
let annotations = [];
let selectedText = null;
let selectedLabel = null;
let currentWorkspaceId = null;

// Get workspace ID from URL parameters
function getWorkspaceId() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('workspace');
}

// Initialize the interface
document.addEventListener('DOMContentLoaded', function() {
    currentWorkspaceId = getWorkspaceId();
    if (!currentWorkspaceId) {
        document.getElementById('text-display').innerHTML = '<p class="text-danger text-center">ì›Œí¬ìŠ¤í˜ì´ìŠ¤ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.</p>';
        return;
    }
    loadWorkspaceInfo();
    loadLabels();
    loadTasks();
});

// Load workspace information
async function loadWorkspaceInfo() {
    try {
        const response = await fetch(`/api/workspaces/${currentWorkspaceId}/`);
        const workspace = await response.json();
        
        // Update workspace name in the header
        const taskNameElement = document.getElementById('current-task-name');
        if (taskNameElement) {
            taskNameElement.textContent = `ì›Œí¬ìŠ¤í˜ì´ìŠ¤: ${workspace.name}`;
        }
        
        // Update page title
        document.title = `${workspace.name} - NER ì£¼ì„ ì‘ì—…ê³µê°„`;
        
    } catch (error) {
        console.error('Error loading workspace info:', error);
        const taskNameElement = document.getElementById('current-task-name');
        if (taskNameElement) {
            taskNameElement.textContent = `ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ${currentWorkspaceId}`;
        }
    }
}

// Load available labels
async function loadLabels() {
    try {
        // Load labels for current workspace (includes global labels)
        const response = await fetch(`/api/labels/?project=${currentWorkspaceId}`);
        const data = await response.json();
        labels = data.results || data;
        renderLabelButtons();
    } catch (error) {
        console.error('Error loading labels:', error);
    }
}

// Load tasks
async function loadTasks() {
    try {
        // Load tasks filtered by current workspace (project)
        const response = await fetch(`/api/tasks/?project=${currentWorkspaceId}`);
        const data = await response.json();
        tasks = data.results || data;
        
        if (tasks.length > 0) {
            loadTask(0);
            // Load file metadata and auto-add extracted labels
            await loadFileMetadata();
        } else {
            document.getElementById('text-display').innerHTML = '<p class="text-muted text-center">ì´ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ì— ì‘ì—…ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
        }
    } catch (error) {
        console.error('Error loading tasks:', error);
        document.getElementById('text-display').innerHTML = '<p class="text-danger text-center">ì‘ì—…ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
    }
}

// Render label buttons
function renderLabelButtons() {
    const container = document.getElementById('label-buttons');
    container.innerHTML = labels.map(label => {
        const color = label.background || '#007bff'; // Use 'background' field from API
        return `<button class="label-button" 
                 style="background-color: ${color}; color: ${getContrastColor(color)}" 
                 onclick="selectLabel('${label.id}')" 
                 data-label-id="${label.id}">
            ${label.value}
         </button>`;
    }).join('');
}

// Load specific task
async function loadTask(index) {
    if (index < 0 || index >= tasks.length) return;
    
    currentTaskIndex = index;
    currentTask = tasks[index];
    
    // Update UI - Keep workspace info and add current task
    const taskNameElement = document.getElementById('current-task-name');
    const currentWorkspaceName = taskNameElement.textContent.split(' - ')[0]; // Keep workspace name
    taskNameElement.textContent = `${currentWorkspaceName} - ì‘ì—… ${index + 1}`;
    document.getElementById('task-counter').textContent = `${index + 1} / ${tasks.length}`;
    document.getElementById('progress-count').textContent = `${index} / ${tasks.length}`;
    
    // Load task text and annotations
    displayTaskText(currentTask.data || currentTask.text || 'í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
    
    // Load existing annotations for this task
    try {
        console.log(`Loading annotations for task ${currentTask.id}`);
        const response = await fetch(`/api/tasks/${currentTask.id}/annotations/`);
        const data = await response.json();
        annotations = data.results || data;
        console.log(`Loaded ${annotations.length} existing annotations:`, annotations);
        
        // Map annotations with label information
        annotations = annotations.map(ann => {
            // Find matching label
            let labelInfo = null;
            if (ann.labels && ann.labels.length > 0) {
                const labelValue = ann.labels[0]; // Get first label
                labelInfo = labels.find(label => label.value === labelValue);
            }
            
            return {
                ...ann,
                label_name: labelInfo ? labelInfo.value : (ann.labels && ann.labels[0]) || 'Unknown',
                label_color: labelInfo ? labelInfo.background : '#6c757d',
                label_id: labelInfo ? labelInfo.id : null,
                start_offset: ann.start,
                end_offset: ann.end
            };
        });
        console.log('Mapped annotations with label info:', annotations);
        
        // If no annotations exist but task has pre-existing annotations from file upload
        if ((!annotations || annotations.length === 0) && currentTask.pre_annotations) {
            try {
                const preExistingAnnotations = currentTask.pre_annotations;
                annotations = preExistingAnnotations.map((ann, index) => ({
                    id: `pre_${index}`,
                    start: ann.start,
                    end: ann.end,
                    label: ann.label,
                    text: ann.text,
                    task: currentTask.id
                }));
                console.log(`ì‚¬ì „ ì •ì˜ëœ ${annotations.length}ê°œì˜ ì–´ë…¸í…Œì´ì…˜ì„ ë¡œë“œí–ˆìŠµë‹ˆë‹¤.`);
            } catch (parseError) {
                console.error('Error parsing pre-existing annotations:', parseError);
                annotations = [];
            }
        }
        
        renderAnnotations();
    } catch (error) {
        console.error('Error loading annotations:', error);
        annotations = [];
    }
    
    // Update navigation buttons
    document.getElementById('prev-btn').disabled = index === 0;
    document.getElementById('next-btn').disabled = index === tasks.length - 1;
}

// Display task text
function displayTaskText(text) {
    const display = document.getElementById('text-display');
    display.innerHTML = `<p>${text}</p>`;
    
    // Add text selection functionality
    display.addEventListener('mouseup', handleTextSelection);
}

// Handle text selection
function handleTextSelection() {
    const selection = window.getSelection();
    if (selection.rangeCount > 0 && selection.toString().trim()) {
        const range = selection.getRangeAt(0);
        const textDisplay = document.getElementById('text-display');
        const fullText = textDisplay.textContent;
        
        // Calculate accurate offsets relative to the full text
        const selectedText_temp = selection.toString().trim();
        const startOffset = fullText.indexOf(selectedText_temp);
        const endOffset = startOffset + selectedText_temp.length;
        
        selectedText = {
            text: selectedText_temp,
            start: startOffset,
            end: endOffset
        };
        
        console.log('Selected text:', selectedText);
        
        // Update label selection status
        updateLabelSelectionStatus();
        
        // Show feedback about text selection
        if (selectedLabel) {
            showToast(`í…ìŠ¤íŠ¸ ì„ íƒë¨: "${selectedText_temp}". ë¼ë²¨ "${selectedLabel.value}"ë¡œ ì–´ë…¸í…Œì´ì…˜ì´ ìƒì„±ë©ë‹ˆë‹¤.`, 'success');
        } else {
            showToast(`í…ìŠ¤íŠ¸ ì„ íƒë¨: "${selectedText_temp}". ë¼ë²¨ì„ ì„ íƒí•˜ì„¸ìš”.`, 'info');
        }
        
        // Highlight selected text visually
        document.querySelectorAll('.selected-text').forEach(el => 
            el.classList.remove('selected-text'));
        
        if (range.toString().trim()) {
            const span = document.createElement('span');
            span.className = 'selected-text';
            try {
                range.surroundContents(span);
            } catch (e) {
                // For complex selections, just highlight with background color
                const commonAncestor = range.commonAncestorContainer;
                if (commonAncestor.nodeType === Node.TEXT_NODE) {
                    commonAncestor.parentElement.classList.add('selected-text');
                }
            }
        }
    }
}

// Select a label
function selectLabel(labelId) {
    // Remove previous selection
    document.querySelectorAll('.label-button.selected').forEach(btn => 
        btn.classList.remove('selected'));
    
    // Select new label
    const selectedButton = document.querySelector(`[data-label-id="${labelId}"]`);
    if (selectedButton) {
        selectedButton.classList.add('selected');
        selectedLabel = labels.find(l => l.id == labelId);
        
        // Show visual feedback
        console.log(`ë¼ë²¨ ì„ íƒë¨: ${selectedLabel.value}`);
        
        // Update label selection status display
        updateLabelSelectionStatus();
        
        // Apply annotation if text is selected
        if (selectedText && selectedLabel) {
            createAnnotation();
        } else if (selectedLabel) {
            showToast(`ë¼ë²¨ "${selectedLabel.value}" ì„ íƒë¨. ì´ì œ í…ìŠ¤íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”.`, 'info');
        }
    }
}

// Create annotation
function createAnnotation() {
    if (!selectedText || !selectedLabel) return;
    
    const annotation = {
        id: Date.now().toString(),
        task_id: currentTask.id,
        label_id: selectedLabel.id,
        text: selectedText.text,
        start_offset: selectedText.start,
        end_offset: selectedText.end,
        labels: [selectedLabel.value],
        label_name: selectedLabel.value,
        label_color: selectedLabel.background
    };
    
    annotations.push(annotation);
    renderAnnotations();
    applyHighlighting();
    clearSelection();
}

// Render annotations list
function renderAnnotations() {
    const container = document.getElementById('annotations-list');
    
    if (annotations.length === 0) {
        container.innerHTML = '<p class="text-muted">ì•„ì§ ì£¼ì„ì´ ì—†ìŠµë‹ˆë‹¤.</p>';
        return;
    }
    
    container.innerHTML = annotations.map((ann, index) => 
        `<div class="mb-2 p-2 border rounded" style="border-color: black; background-color: ${ann.label_color}">
            <strong style="color: ${getContrastColor(ann.label_color)}">${ann.labels[0]}</strong><br>
            <small class="text5" style="color: ${getContrastColor(ann.label_color)}">"${ann.text}"</small>
            <button class="btn btn-sm btn-outline-danger float-end" onclick="removeAnnotationById('${ann.id}')">
                <i class="fas fa-times"></i>
            </button>
         </div>`
    ).join('');
}

// Apply highlighting to annotated text
function applyHighlighting() {
    // This would need more complex implementation for proper text highlighting
    console.log('Highlighting annotations:', annotations);
}

// Navigation functions
function previousTask() {
    if (currentTaskIndex > 0) {
        loadTask(currentTaskIndex - 1);
    }
}

function nextTask() {
    if (currentTaskIndex < tasks.length - 1) {
        loadTask(currentTaskIndex + 1);
    }
}

// Utility functions
function clearSelection() {
    selectedText = null;
    selectedLabel = null;
    
    document.querySelectorAll('.selected-text').forEach(el => {
        const parent = el.parentNode;
        parent.insertBefore(document.createTextNode(el.textContent), el);
        parent.removeChild(el);
    });
    
    document.querySelectorAll('.label-button.selected').forEach(btn => 
        btn.classList.remove('selected'));
    
    // Update status display
    updateLabelSelectionStatus();
    
    showToast('ì„ íƒì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
}

function removeAnnotation() {
    if (selectedText) {
        // Remove annotation for selected text
        annotations = annotations.filter(ann => ann.text !== selectedText.text);
        renderAnnotations();
        clearSelection();
    }
}

function removeAnnotationById(annotationId) {
    annotations = annotations.filter(ann => ann.id !== annotationId);
    renderAnnotations();
    applyHighlighting();
}

// Update label selection status display
function updateLabelSelectionStatus() {
    const statusElement = document.getElementById('label-selection-status');
    if (statusElement) {
        if (selectedLabel) {
            statusElement.innerHTML = `
                <div class="alert alert-info py-2">
                    <i class="fas fa-tag me-1"></i>
                    ì„ íƒëœ ë¼ë²¨: <strong style="color: ${selectedLabel.background}">${selectedLabel.value}</strong>
                    ${selectedText ? '- í…ìŠ¤íŠ¸ë„ ì„ íƒë¨' : '- í…ìŠ¤íŠ¸ë¥¼ ì„ íƒí•˜ì„¸ìš”'}
                </div>
            `;
        } else {
            statusElement.innerHTML = '<div class="alert alert-secondary py-2"><i class="fas fa-info-circle me-1"></i>ë¼ë²¨ì„ ì„ íƒí•˜ì„¸ìš”</div>';
        }
    }
}

function getContrastColor(hexcolor) {
    // Handle undefined or invalid colors
    if (!hexcolor || typeof hexcolor !== 'string') {
        return 'black';
    }
    
    // Ensure color starts with #
    if (!hexcolor.startsWith('#')) {
        hexcolor = '#' + hexcolor;
    }
    
    // Handle short hex colors (#fff -> #ffffff)
    if (hexcolor.length === 4) {
        hexcolor = '#' + hexcolor[1] + hexcolor[1] + hexcolor[2] + hexcolor[2] + hexcolor[3] + hexcolor[3];
    }
    
    // Ensure we have a valid 7-character hex color
    if (hexcolor.length !== 7) {
        return 'black';
    }
    
    const r = parseInt(hexcolor.substr(1,2),16);
    const g = parseInt(hexcolor.substr(3,2),16);
    const b = parseInt(hexcolor.substr(5,2),16);
    
    // Check for NaN values
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
        return 'black';
    }
    
    const yiq = ((r*299)+(g*587)+(b*114))/1000;
    return (yiq >= 128) ? 'black' : 'white';
}

// Save annotations
async function saveAnnotations() {
    if (!currentTask) {
        alert('ì‘ì—…ì´ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        return;
    }

    try {
        // Clear existing annotations for this task first
        const existingResponse = await fetch(`/api/tasks/${currentTask.id}/annotations/`);
        if (existingResponse.ok) {
            const existingAnnotations = await existingResponse.json();
            const annotationsToDelete = existingAnnotations.results || existingAnnotations;
            
            // Delete existing annotations
            for (const existingAnn of annotationsToDelete) {
                await fetch(`/api/annotations/${existingAnn.id}/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken')
                    }
                });
            }
        }

        // Create new annotations
        let successCount = 0;
        for (const annotation of annotations) {
            const annotationData = {
                task: currentTask.id,
                start: annotation.start_offset,
                end: annotation.end_offset,
                text: annotation.text,
                labels: [annotation.label_name], // Convert to array format expected by backend
                label_id: annotation.label_id // Include label_id if available
            };

            console.log('Saving annotation:', annotationData); // Debug log

            const response = await fetch('/api/annotations/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify(annotationData)
            });

            if (response.ok) {
                const result = await response.json();
                console.log('Annotation saved successfully:', result);
                successCount++;
            } else {
                const errorText = await response.text();
                console.error('Error saving annotation:', {
                    status: response.status,
                    statusText: response.statusText,
                    body: errorText,
                    annotation: annotationData
                });
            }
        }

        showToast(`${successCount}ê°œì˜ ì–´ë…¸í…Œì´ì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!`, `${successCount}ê°œì˜ ì–´ë…¸í…Œì´ì…˜ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!`);
        
    } catch (error) {
        console.error('Error saving annotations:', error);
        showToast('ì–´ë…¸í…Œì´ì…˜ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
    }
}

// Export functions
function exportJSON() {
    const data = {
        task: currentTask,
        annotations: annotations
    };
    downloadFile(JSON.stringify(data, null, 2), 'annotations.json', 'application/json');
}

function exportCoNLL() {
    // CoNLL format implementation
    let conll = '';
    // Add CoNLL formatting logic here
    downloadFile(conll, 'annotations.conll', 'text/plain');
}

function exportLabelStudio() {
    // Label Studio format implementation
    const lsData = {
        data: currentTask,
        annotations: [{
            result: annotations.map(ann => ({
                from_name: "label",
                to_name: "text", 
                type: "labels",
                value: {
                    start: ann.start_offset,
                    end: ann.end_offset,
                    text: ann.text,
                    labels: [ann.label_name]
                }
            }))
        }]
    };
    downloadFile(JSON.stringify(lsData, null, 2), 'label_studio.json', 'application/json');
}

function downloadFile(content, filename, contentType) {
    const a = document.createElement('a');
    const file = new Blob([content], {type: contentType});
    a.href = URL.createObjectURL(file);
    a.download = filename;
    a.click();
}

// File Upload Functions
function dragOverHandler(ev) {
    ev.preventDefault();
}

function dragEnterHandler(ev) {
    ev.preventDefault();
    document.getElementById('upload-area').classList.add('dragover');
}

function dragLeaveHandler(ev) {
    ev.preventDefault();
    document.getElementById('upload-area').classList.remove('dragover');
}

function dropHandler(ev) {
    ev.preventDefault();
    document.getElementById('upload-area').classList.remove('dragover');
    
    const files = ev.dataTransfer.files;
    if (files.length > 0) {
        uploadFile(files[0]);
    }
}

function handleFileSelect(event) {
    const files = event.target.files;
    if (files.length > 0) {
        uploadFile(files[0]);
    }
}

async function uploadFile(file) {
    if (!currentWorkspaceId) {
        alert('ì›Œí¬ìŠ¤í˜ì´ìŠ¤ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
        return;
    }
    
    // Check file type
    const allowedTypes = ['txt', 'csv', 'tsv', 'json', 'jsonl'];
    const fileExtension = file.name.toLowerCase().split('.').pop();
    
    if (!allowedTypes.includes(fileExtension)) {
        alert(`ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤. ì§€ì› í˜•ì‹: ${allowedTypes.join(', ').toUpperCase()}`);
        return;
    }
    
    // Check file size (16MB)
    if (file.size > 16 * 1024 * 1024) {
        alert('íŒŒì¼ í¬ê¸°ê°€ ë„ˆë¬´ í½ë‹ˆë‹¤. ìµœëŒ€ 16MBê¹Œì§€ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
        return;
    }
    
    // Show progress
    const uploadProgress = document.getElementById('upload-progress');
    const progressBar = uploadProgress.querySelector('.progress-bar');
    const statusText = document.getElementById('upload-status');
    
    uploadProgress.style.display = 'block';
    progressBar.style.width = '10%';
    statusText.textContent = `íŒŒì¼ ì—…ë¡œë“œ ì¤‘... (${file.name})`;
    
    try {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('project_id', currentWorkspaceId);
        formData.append('uploader_name', sessionStorage.getItem('memberName') || 'Anonymous');
        
        const response = await fetch('/api/v1/upload/', {
            method: 'POST',
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: formData
        });
        
        progressBar.style.width = '60%';
        statusText.textContent = 'íŒŒì¼ ì²˜ë¦¬ ì¤‘...';
        
        if (response.ok) {
            const result = await response.json();
            
            progressBar.style.width = '100%';
            progressBar.style.backgroundColor = '#28a745';
            statusText.innerHTML = `
                <strong>ì„±ê³µ!</strong><br>
                ${result.total_lines}ì¤„ì—ì„œ ${result.tasks_created}ê°œì˜ ì‘ì—…ì„ ìƒì„±í–ˆìŠµë‹ˆë‹¤.
            `;
            
            // Add to file history
            addFileToHistory(result.uploaded_file, 'success');
            
            // Hide progress after 4 seconds and reload tasks
            setTimeout(() => {
                uploadProgress.style.display = 'none';
                progressBar.style.width = '0%';
                progressBar.style.backgroundColor = '#28a745';
                document.getElementById('file-input').value = '';
                
                // Reload tasks to show new ones
                loadTasks();
            }, 4000);
            
        } else {
            const errorData = await response.json();
            throw new Error(errorData.error || 'ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
        
    } catch (error) {
        console.error('Upload error:', error);
        
        progressBar.style.width = '100%';
        progressBar.style.backgroundColor = '#dc3545';
        statusText.innerHTML = `<strong>ì˜¤ë¥˜:</strong> ${error.message}`;
        
        // Add to file history
        addFileToHistory({
            original_filename: file.name,
            file_type: fileExtension,
            error_message: error.message,
            processing_status: 'failed'
        }, 'failed');
        
        // Hide progress after 6 seconds
        setTimeout(() => {
            uploadProgress.style.display = 'none';
            progressBar.style.width = '0%';
            progressBar.style.backgroundColor = '#28a745';
            document.getElementById('file-input').value = '';
        }, 6000);
    }
}

// File history management
function addFileToHistory(fileData, status) {
    const historySection = document.getElementById('file-history');
    const historyList = document.getElementById('file-history-list');
    
    // Show history section
    historySection.style.display = 'block';
    
    // Create history item
    const historyItem = document.createElement('div');
    historyItem.className = `file-history-item ${status}`;
    
    const statusIcon = status === 'success' ? 'âœ…' : status === 'failed' ? 'âŒ' : 'â³';
    const statusText = status === 'success' ? 
        `${fileData.tasks_created}ê°œ ì‘ì—… ìƒì„±` : 
        status === 'failed' ? 
        `ì‹¤íŒ¨: ${fileData.error_message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}` : 
        'ì²˜ë¦¬ ì¤‘...';
    
    historyItem.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0;">
            <span style="font-size: 14px;">${statusIcon}</span>
            <div style="flex: 1; min-width: 0;">
                <div style="font-weight: 500; color: #2c3e50; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                    ${fileData.original_filename}
                </div>
                <div style="font-size: 11px; color: #6c757d;">
                    ${statusText}
                </div>
            </div>
        </div>
        <div style="font-size: 11px; color: #6c757d; white-space: nowrap;">
            ${fileData.file_type?.toUpperCase() || 'FILE'}
        </div>
    `;
    
    // Add to top of list
    historyList.insertBefore(historyItem, historyList.firstChild);
    
    // Keep only last 5 items
    while (historyList.children.length > 5) {
        historyList.removeChild(historyList.lastChild);
    }
}

// Load file history on page load
async function loadFileHistory() {
    if (!currentWorkspaceId) return;
    
    try {
        const response = await fetch(`/api/v1/uploaded-files/?project=${currentWorkspaceId}`);
        if (response.ok) {
            const files = await response.json();
            console.log('File history response:', files);
            
            // Ensure files is an array
            const filesArray = Array.isArray(files) ? files : (files.results || []);
            if (filesArray.length > 0) {
                document.getElementById('file-history').style.display = 'block';
                files.slice(0, 5).forEach(file => {
                    const status = file.processing_status === 'completed' ? 'success' : 
                                 file.processing_status === 'failed' ? 'failed' : 'processing';
                    addFileToHistory(file, status);
                });
            }
        }
    } catch (error) {
        console.error('Error loading file history:', error);
    }
}

// Load file metadata and display it
async function loadFileMetadata() {
    if (!currentWorkspaceId) return;
    
    try {
        const response = await fetch(`/api/v1/uploaded-files/?project=${currentWorkspaceId}`);
        if (response.ok) {
            const files = await response.json();
            console.log('Raw files response:', files);
            
            // Ensure files is an array
            const filesArray = Array.isArray(files) ? files : (files.results || []);
            const filesWithMetadata = filesArray.filter(file => file.file_metadata || file.extracted_labels);
            
            if (filesWithMetadata.length > 0) {
                displayMetadataPanel(filesWithMetadata);
                
                // Auto-add extracted labels to project
                //await autoAddExtractedLabels(filesWithMetadata);
            }
        }
    } catch (error) {
        console.error('Error loading file metadata:', error);
    }
}

// Display metadata panel
function displayMetadataPanel(files) {
    const metadataHtml = `
        <div class="metadata-panel" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #007bff;">
            <h6><i class="fas fa-info-circle"></i> íŒŒì¼ ë©”íƒ€ë°ì´í„°</h6>
            ${files.map(file => {
                const metadata = file.file_metadata || {};
                const labels = file.extracted_labels || [];
                
                return `
                    <div class="file-metadata" style="margin-bottom: 10px;">
                        <strong>${file.original_filename}</strong>
                        ${metadata.total_unique_entities ? `<span class="badge badge-info ml-2">${metadata.total_unique_entities}ê°œ ì—”í‹°í‹° íƒ€ì…</span>` : ''}
                        ${labels.length > 0 ? `
                            <div style="margin-top: 5px;">
                                <small class="text-muted">ì¶”ì¶œëœ ë¼ë²¨:</small>
                                ${labels.map(label => `<span class="badge badge-secondary badge-sm ml-1">${label}</span>`).join('')}
                            </div>
                        ` : ''}
                        ${metadata.data_ids && metadata.data_ids.length > 0 ? `
                            <div style="margin-top: 5px;">
                                <small class="text-muted">ë°ì´í„° ID: ${metadata.data_ids.length}ê°œ</small>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('')}
        </div>
    `;
    
    // Insert metadata panel before task navigation
    const taskNav = document.querySelector('.task-navigation');
    if (taskNav) {
        taskNav.insertAdjacentHTML('beforebegin', metadataHtml);
    }
}

// Auto-add extracted labels to project
async function autoAddExtractedLabels(files) {
    const allExtractedLabels = new Set();
    
    // Collect all unique labels from all files
    files.forEach(file => {
        if (file.extracted_labels) {
            file.extracted_labels.forEach(label => allExtractedLabels.add(label));
        }
    });
    
    if (allExtractedLabels.size === 0) return;
    
    try {
        // Get current project labels
        const currentLabelsResponse = await fetch(`/api/v1/labels/?project=${currentWorkspaceId}`);
        const currentLabelsData = currentLabelsResponse.ok ? await currentLabelsResponse.json() : [];
        const currentLabels = Array.isArray(currentLabelsData) ? currentLabelsData : (currentLabelsData.results || []);
        const existingLabelValues = new Set(currentLabels.map(label => label.value));
        
        // Create labels that don't exist yet
        const labelsToCreate = Array.from(allExtractedLabels).filter(label => !existingLabelValues.has(label));
        
        if (labelsToCreate.length > 0) {
            console.log(`ìë™ìœ¼ë¡œ ${labelsToCreate.length}ê°œì˜ ìƒˆë¡œìš´ ë¼ë²¨ì„ ì¶”ê°€í•©ë‹ˆë‹¤:`, labelsToCreate);
            
            // Color palette for new labels
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e', '#e67e22'];
            
            const labelPromises = labelsToCreate.map((labelValue, index) => {
                const labelData = {
                    value: labelValue,
                    background: colors[index % colors.length],
                    text: '#ffffff',
                    project: currentWorkspaceId
                };
                
                return fetch('/api/v1/labels/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify(labelData)
                });
            });
            
            await Promise.all(labelPromises);
            
            // Reload labels to show the new ones
            await loadLabels();
            
            // Show success message
            showToast(`${labelsToCreate.length}ê°œì˜ ìƒˆë¡œìš´ ë¼ë²¨ì´ ìë™ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!`, 'success');
        }
    } catch (error) {
        console.error('Error auto-adding labels:', error);
        showToast('ë¼ë²¨ ìë™ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
    }
}

// Show toast message
function showToast(message, type = 'info') {
    const toast = document.createElement('div');
    toast.className = `alert alert-${type === 'success' ? 'success' : type === 'error' ? 'danger' : 'info'} alert-dismissible fade show`;
    toast.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
    toast.innerHTML = `
        ${message}
        <button type="button" class="close" data-dismiss="alert">
            <span>&times;</span>
        </button>
    `;
    
    document.body.appendChild(toast);
    
    // Auto remove after 5 seconds
    setTimeout(() => {
        if (toast.parentNode) {
            toast.parentNode.removeChild(toast);
        }
    }, 5000);
}

// Utility function to get CSRF cookie
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// Click handler for upload area
document.addEventListener('DOMContentLoaded', function() {
    const uploadArea = document.getElementById('upload-area');
    if (uploadArea) {
        uploadArea.addEventListener('click', () => {
            document.getElementById('file-input').click();
        });
    }
    
    // Load file history when workspace is loaded
    setTimeout(loadFileHistory, 1000);
});
</script>
{% endblock %}